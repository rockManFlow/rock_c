# rock-c





### 问题列表
* 14、C的内存管理
* 15、学习新的好的项目
* 17、C编写需要配置的环境有哪些
* 18、ffmpeg项目讲解，如何来整合调用这些库的功能
* 21、驱动程序+嵌入式程序如何编写
* 22、短视频直播实现技术
* 23、个人程序员如何在未来有自己的一席之地
* 
* 25、C中库文件是什么时候导进去的，如何让依赖的三方库成为库包，可以通过include <>访问---安装到本地
* 27、作用域、存储类别、链接和内存管理
* 28、文件输入输出，标准 I/O 通信
* 29、结构体、联合、枚举、函数指针
* 30、三方库libevent接入项目使用+看懂代码



# QA
### 0、C的优缺点
C是面向过程编程，语法简洁  
Ｃ语言中即使是再微小的事情都有安全隐患。它不是用来编写大型的商业软件的。  
初衷是为了让编译器和库的编写者可充分利用计算机每一个bit的计算能力，初衷就是为了快  
系统级编程、嵌入式系统和驱动程序等领域--底层领域  
C语言的源代码可以直接转化为机器码，而其他语言的源代码则需要经过编译、解释等环节才能转化为机器码。这使得C语言在需要高效率的场景中更为适用  
编译成机器码之后是某些机器的适用的机器码，不同机器的不同系统机器码会不同  
### 1、C的数据类型
![数据类型.png](数据类型.png)  
C语言中定义了6种基本数据类型：short,int,long,float,double,char  
4种构造类型：数组，结构体（struct），共用类型(union)，枚举类型(enum)  
指针类型和空类型  
### 2、typedef unsigned char  __uint8_t 作用？
typedef为C语言的关键字  
作用是为一种数据类型定义一个新名字。  
这里的数据类型包括内部数据类型（int,char等）和自定义数据类型（struct等）  

### 3、#define作用
#define 定义一个标识符来表示一个常量。  
其特点是定义的标识符不占内存，只是一个临时的符号，预编译后这个符号就不存在了（使用的地方在预编译的时候会直接替换成对应常量值，所以说符号就不存在了）。  
用 #define 定义标识符的一般形式为：  
#define 标识符 常量 //注意, 最后没有分号  
#define 和 #include 一样，也是以“#”开头的。凡是以“#”开头的均为预处理指令，#define也不例外。  
示例
>#define UINT unsigned int  
>在程序中可用 UINT 作变量说明：  
>UINT a, b;

宏定义只是简单的字符串替换，由预处理器来处理.比如：UINT a, b;变成 unsigned int a, b;

### 4、C中头文件的作用和保存什么内容
C 函数声明和宏定义，被多个源文件中引用共享。有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。  
在程序中要使用头文件，需要使用 C 预处理指令 #include 来引用它，在预处理阶段，会把引用的头文件内容复制到源文件中  
建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。  
#include <file> 这种形式用于引用系统头文件。它在系统目录的标准列表中搜索名为 file 的文件  
#include "file" 这种形式用于引用用户头文件。它在包含当前文件的目录中搜索名为 file 的文件  

### 5、输入输出
scanf() 函数用于从标准输入（键盘）读取并格式化， printf() 函数发送格式化输出到标准输出（屏幕）。  

### 6、C中字符串如何表示
在 C 语言中，字符串实际上是使用空字符 \0 结尾的一维字符数组。因此，\0 是用于标记字符串的结束。
char arr[]={'x','b'};  char site[] = "RUNOOB";  

### 7、指针如何来操作
& 运算符访问的地址。指针类型必须与变量类型一致。  
指针中对应的值存的是变量的地址，%p取的是指针的值（及存的变量的地址信息）  
想取指针存的地址对应的值信息，使用*p  

### 8、判断逻辑
switch 语句中的 expression 是一个常量表达式，必须是一个整型或枚举类型。  
goto用法
`goto labelname;  
..  
.  
labelname: statement;`

### 9、C程序从创建到执行流程
在完成 .c 或 .cpp 文件的编写后，我们通常直接 gcc 或 g++ 后接文件名，就可以在当前文件夹下生成 a.out 可执行文件, 之后输入 ./a.out 即可执行该二进制可执行文件。  
gcc命令后面不加选项的话，就会默认执行预处理、编译、汇编、链接所有步骤，若程序没有错误的话，我们就可以得到一个可执行文件，默认为 a.out。  
![创建到执行流程.png](创建到执行流程.png)  
-E选项：编译器执行完预处理阶段就停止执行，后面的编译、汇编等操作就不会执行。  
-S选项：编译器执行完编译阶段就会停止。  
-c选项：编译器执行完汇编阶段就会停止。  
详情：
- 1、编写.c文件
- 2、预处理  
    对于使用#例如#define 和#include的会把对应的常量或者头文件替换成具体内容
- 3、编译（将文件编译成汇编语言）
- 4、汇编（将汇编代码变成机器码，生成目标文件 .o (windows下为 .obj ) ）
- 5、链接（生成可执行文件 win中是exe程序，Linux中是.out可执行程序）

>GCC命令行的一个选项:  
>（1）-shared 。该选项指定gcc编译器生成动态连接库，而不是可执行文件  
>（2）-fPIC：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，
> 而不能达到真正代码段共享的目的。正是使用这个，使得动态链接库不用再编译时拷贝库函数的完整代码，实现真正的动态链接。  
>（3）-L：指定编译的时候动态链接库的位置，这里使用  -L. 后面跟了一个点表示要连接的库在当前目录中  
>（4）-ltest：编译器查找动态连接库时有隐含的命名规则，即在给出的名字前面加上lib，后面加上.so来确定库的名称  
>另外：
>（1）LD_LIBRARY_PATH：这个环境变量指示动态连接器可以装载动态库的路径。  
>（2）当然如果有root权限的话，可以修改/etc/ld.so.conf文件，然后调用 /sbin/ldconfig来达到同样的目的，不过如果没有root权限，
> 那么只能采用输出LD_LIBRARY_PATH的方法了。  

### 10、C源文件中引入的头文件中的函数，如何找到函数实现的
函数的声明放到头文件（.h文件）中，使用函数时引入对应的头文件就可以，编译器会在链接阶段找到函数体。  
链接会将前面编译好的.o文件、系统库的.o文件和库文件彼此相连接，有默认库文件加载路径，也可以指定库文件加载路径，指明从哪些库文件来链接  
如果是用gcc，那就需要用参数（-l -L）去指定这些库的名字及路径  

> 源文件编译后成生了目标文件（.o或.obj文件），目标文件中，这些函数和变量就视作一个个符号。  
> 在link的时候，需要在makefile里面说明需要连接哪个.o或.obj文件（在这里是b.cpp生成的.o或.obj文件），  
> 此时，连接器会去这个.o或.obj文件中找在b.cpp中实现的函数，再把他们build到makefile中指定的那个可以执行文件中。  
> 在VC中，一帮情况下不需要自己写makefile，只需要将需要的文件都包括在project中，VC会自动帮你把makefile写好。

### 11、一个C中如何引用另外一个C的实现的逻辑
在C中通过引用其的.h文件来使用其对应的函数实现。之后再把对应的lib包含进项目中。  
引入第三方包的方式  
1. 直接引入三方包实现的源文件--及直接在项目中添加三方的.c文件
2. gcc 会分别编译 main.c 和 sum.c（三方源文件），最后再把他们链接起来构成最终的 main 程序。--gcc main.c ./thirdparty/sum.c -o main  

**将GoogleTest源码下载到本地，从源码编译安装到指定路径，然后再使用静态或者动态链接的方式进行调用**  
3. 引入头文件和静态库  
   <font color=red size=2>静态库文件是多个目标文件（机器码文件，但还没链接成可执行文件）放到一起的文件</font>  
  目标文件（Object，.o 结尾）是由源文件（.c、.cpp）编译但还未链接得到的二进制文件，目标文件此时已完成为了编译流程（预处理 -> 编译 -> 组装 -> 链接）中的前三步。  
  那什么又是静态库呢，怎样获得静态库呢？  
  静态库是由多个目标文件打包到一起得到的二进制文件，命名约定俗成以 lib 开头，中间是库名，然后是 .a 结尾，形如：libNAME.a  
    1. 编译成目标文件 gcc -c ./thirdparty/sum.c -o sum.o  
    2. sum.o 打包到静态库中，这里需要用到一个命令 ar（archive 的缩写  
       参数：-r replace 如果静态库中目标文件已存在，则替换为最新的。  
       -c 如果静态库不存在，在创建的时候不用弹出警告提示。  
       ar -rc libsum.a sum.o xxx.o 多个目标文件打入到libsum.a静态库中。
   3. 查看静态库中目标文件列表可以用 ar -t libsum.a  
      把 main.c 和 上一步输出的静态库 libsum.a 合在一起编译出最终的可执行程序。  
      **生成最终可执行程序 gcc main.c libsum.a -o main 或者gcc -o hello main.c -static -L. -lmyhello**
      **-static代表使用静态链接库，-L.代表静态链接库搜索路径 .代表当前路径**

|  ar命令参数  |   意义  |
|  ------ |------------------------------------------  |
|  -r    |  将objfile文件插入静态库尾或者替换静态库中同名文件  |
|  -x    |  从静态库文件中抽取文件objfile  |
|  -t    |  打印静态库的成员文件列表  |
|  -d    |  从静态库中删除文件objfile  |
|  -s    |  重置静态库文件索引  |
|  -v    |  创建文件冗余信息  |
|  -c    |  创建静态库文件  |  
   
4. 引入头文件和动态链接库
   把常用的一些函数功能都封装到了这些共享库（Shared Object，后缀 .so）中。  
   在编译程序时共享库的内容并不打包到最终的可执行程序中，而是在程序执行时动态链接调用，因此这些共享库通常也被称之为动态链接库，程序运行时会自动到 /lib 和 /usr/lib 等库目录去搜索，当然你也可以指定一个自己的库目录。  
   构建自己的动态链接库 ：gcc -shared ./thirdparty/sum.c -o libsum.so  
   **接着去生成 main.c 的可执行程序：gcc main.c -o main -L. -lsum -Wl,-rpath=.**
   > -L. 指定编译时自定义的链接库目录，. 代表当前目录。  
   > -lsum 指定要动态链接的库，只需写名字，系统会自动加前后缀，即：libsum.so  
   > -Wl,-rpath=. 首先 -Wl,<option> 是传递选项给链接器，选项之间用 , 号分隔，-rpath=. 这个选项设置了程序运行时自定义库的目录为当前目录。  

### 12、sizeof函数的作用
返回一个对象或者类型所占的内存字节数  
取得一个对象（数据类型或者数据对象）的长度(即占用内存的大小，以byte为单位)。其中类型包含基本数据类型（不包括void）、用户自定义类型（结构体、类）、函数类型  
tip:当sizeof的参数是数组名时，计算的是整个数组的存储大小；当sizeof的参数是指针时，计算的是指针的大小（8字节，64位系统）
   **length=(sizeof(a) / sizeof(int));** 
### 13、exit(1)作用
功 能: 关闭所有文件，终止正在执行的进程。  
exit(1)表示异常退出.这个1是返回给操作系统的。  
exit(x)（x不为0）都表示异常退出  
exit(0)表示正常退出  

### 14、C环境配置
1. 需要在运行机器上安装gcc编译器，用于编译C源码
2. 剩余就是编辑C源码的工具

### 15、ifndef和endif的用法
ifndef x //if not define的简写  宏定义的一种  
条件指示符#ifndef 的最主要目的是防止头文件的重复包含和编译  
```
#ifndef x //先测试x是否被宏定义过
#define x
程序段1 //如果x没有被宏定义过，定义x，并编译程序段1
#endif

程序段2 //如果x已经定义过了则编译程序段2的语句，“忽视”程序段1。

千万不要忽略了头文件中的#ifndef，这是一个很关键的东西。比如你有两个C文件，这两个C文件都include了同一个头文件。而编译时，这两个C文件要一同编译成一个可运行文件，于是问题来了，大量的声明冲突。
　　还是把头文件的内容都放在#ifndef和#endif中吧。不管你的头文件会不会被多个文件引用，你都要加上这个。一般格式是这样的：
　　#ifndef <标识>
　　#define <标识>
　　……
　　……
　　#endif

<标识>在理论上来说可以是自由命名的，但每个头文件的这个“标识”都应该是唯一的。标识的命名规则一般是头文件名全大写，前面加下划线，并把文件名中的“.”也变成下划线，如：stdio.h
　　#ifndef _STDIO_H
　　#define _STDIO_H
　　……
#endif
```

### 16、static关键字的作用--静态
1. 修饰局部变量，成为静态变量，存储在静态区。作用域在局部
2. 修饰全局变量，只能被包含该定义的文件访问（即改变了作用域）
3. static修饰函数使得函数只能在包含该函数定义的文件中被调用，作用域在本文件
4. 修饰成员变量成为全局变量
5. 用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数
6. 所有未加static前缀的全局变量和函数都具有全局可见性，static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏。

### 17、C中常量定义
1、#define 常量名 常量值  
2、const 数据类型 常量名 = 常量值  

### 18、#include 的用法
使用尖括号< >，编译器会到系统路径下查找头文件；  
而使用双引号" "，编译器首先在当前目录下查找头文件，如果没有找到，再到系统路径下查找。 

### 19、C编写的项目，提供有java的sdk是如何实现的
- 做成动态库来调用？

### 20、静态链接库如何来调用
依赖静态库，在项目中把对应的.h放到开发项目中，最终调试也得通过命令来。  
例如：gcc second.c ../lib/libCall.a -o second  
最后执行./second就会执行。注意：静态库中别包含main函数，如果包含最终会失败，因为不知道执行哪个main函数  
但编辑器CLion中不能直接执行了，只能通过命令来执行。  

### 21、动态链接库如何来调用
生成动态链接库文件xx.so  
在项目中#include动态链接库的.h文件，在目标文件中直接使用对应声明的函数。  
在通过命令生成最终可执行程序 gcc main.c -o main -L. -lsum -Wl,-rpath=.  